# Ревью

## Плюсы
- Кандидат предусмотрел рост зависимостей в сервисе
- Стоит отметить, что кандидат выбрал интересный подход для расширения ендпоинтов, чтобы декларативно описывать новые хендлеры


## Минусы
-> Не понятны присутствия компонентов Service, DB и Rspository.
 Одно от другого отличается тем, что в компоненте Repository присутствует бизнес логика,
 когда в компоненте Service пусто. Кажется, что можно перенести логику из Repository в Service и тогда будет логично.
 Сам же Respositry можно и вовсе удалить. Пока что не понятно, зачем вообще тогда нужен компонент Service.
<- Компоненты Service отвечают за БЛ приложения, это прослойка между репозиторием или клиентом, например для обращения в другой сервис.
Т.е. сервис занимает запросом и обработкой данных.
Repository - представляет собой компонент, который по идее должен содержать в себе точку коннекта к базе данных, методы репозитория заключаются
в построении sql запросов в соответствии с используемой orm.
В данном случа из-за имитации реализации транзакции - пришлось переместить БЛ в репозиторий, т.к. именно он отвечал бы за старт и конец транзакции.
Возможно, если orm позволяет, то можно из сервиса реализовать вызов старта, методов с sql запросами и окончания транзакции из сервиса
 чз репозиторий. Чтобы БЛ оставалась в сервисе.
Db - эмулирует базу данных, которая обычно не отражена в коде микросервисов. Если происходит переход на новый способ хранения данных,
то достаточно будет переписать методы репозитория.

-> Кандидат не предусмотрел, что при вызове mutex в компоненте Respository мы полностью блокируем хранилище и на чтение и на запись.
 Это в совокупности даст плохой перфоманс приложения
<- В данном случае акцент был сделан на то, чтобы показать что работа с двумя стораджами осуществляется в рамках транцакции,
 для чего оба стораджа должны быть заблокированы на чтение и запись на время выполнения транзакции,
как это было бы с таблицами.

-> Компонент Repository на множество случаев отдает пустые респонсы и ошибки (nil, nil). В таком случае, нам никак не понять что вообще произошло
и по какой причине код отработал не так, как задумывалось.
Вообще, nil - nil, это антипаттерн. Так как компоненту выше по иерархии, теперь придется проверять не только ошибку,
 но еще и респонс, завязывая на этом свою логику.
<-Если я правильно понимаю, то нужно больше информации почему не был обработан запрос на уровне Repository. В методе TakeTimeSlot nil, nil
возвращается в случае:
1) когда не были найдены в целом охватывающие по времени заказ слоты
2) когда не были найдены доступные по capacity слоты
3) заглушка
В обоих случаях была цель донести до контроллера, что слотов нет - а значит следует вернуть 500.
Возможно, стоит вынести проброс ошибки на уровень Service, но кмк не в Repository.
Т.к Repository отвечает за запросы к базе, а не БЛ и по моему опыту запросы к базе либо возвращают (data, error) либо error.

-> Не до конца понятно, что Handlers делают в App. Если я правильно понял, то App - это наш DI контейнер.
Получается пакет App отвечает за наше приложение в целом, когда http хендлеры это всего лишь часть нашего user interface.
Логичнее всего хранить хендлеры рядом с http сервером, так как они про одно и тоже и не могут жить раздельно.
<- Да, в целом это звучит логично, здесь я пожалуй опиралась на прошлый опыт, где в app хранились имплементации grpc gateway.


Что было не понятно из тз:
(Понятно, что пречь идет об MVP, здесь лично мои вопросы, возникающие в процессе выполнения задания)
1) Например пересекаются таймслоты по времени или нет, от этого зависела реализация поиска подходящих
Должны ли таймслоты быть одинаковыми по времени и идут ли они последовательно или прерываются.
Вообще для полного понимания цикла жизни слотов было бы хорошо знать например как и по какой логике слоты поступают в хранилище,
тогда было бы проще определить процесс поиска необходимых слотов для заказа.

2) Что имеется ввиду под актуальностью данных для аналитиков, есть ли тут скрытый смысл, что должны хранится только актуальные на текущий
и будущий момент заказы, а не исторические

3) И почему в response возвращается Order, вообще не хватало информации как будет работать со стороны UI в зависимости от возвращаемых данных

